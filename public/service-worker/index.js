import { clientsClaim } from 'workbox-core'
import { ExpirationPlugin } from 'workbox-expiration'
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies'

clientsClaim()

// Precache all of the assets generated by your build process.
precacheAndRoute(self.__WB_MANIFEST)

// Cache CSS files with a Cache First strategy
registerRoute(
    ({ request }) => request.destination === 'style',
    new CacheFirst({
        cacheName: 'css-cache',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 50,
                maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
            }),
        ],
    })
)

// Дополнительное правило для кэширования CSS файлов по расширению
registerRoute(
    ({ url }) => url.pathname.endsWith('.css'),
    new CacheFirst({
        cacheName: 'css-cache',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 50,
                maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
            }),
        ],
    })
)

// Cache JavaScript files with a Stale While Revalidate strategy
registerRoute(
    ({ request }) => request.destination === 'script',
    new StaleWhileRevalidate({
        cacheName: 'js-cache',
    })
)

// Cache images with a Cache First strategy
registerRoute(
    ({ request }) => request.destination === 'image',
    new CacheFirst({
        cacheName: 'images',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 60,
                maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
            }),
        ],
    })
)

// Use a Network First strategy for everything else
registerRoute(
    ({ request }) => request.destination === 'document' || request.destination === '',
    new NetworkFirst({
        cacheName: 'others',
        networkTimeoutSeconds: 10,
    })
)

// Добавим логирование для отслеживания кэширования
self.addEventListener('fetch', (event) => {
    console.log('Fetch event for ', event.request.url)
})

self.addEventListener('install', (event) => {
    console.log('Service worker installed')
})

self.addEventListener('activate', (event) => {
    console.log('Service worker activated')
})

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting()
    }
})


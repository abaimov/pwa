import { clientsClaim } from 'workbox-core'
import { ExpirationPlugin } from 'workbox-expiration'
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies'

clientsClaim()

const MAIN_ORIGIN = 'https://pwa-three-wheat1.vercel.app'
const LOCAL_API = 'http://localhost:8000/api/link'
const DOMAIN_UNAVAILABLE_FLAG = 'domain_unavailable'

// Precache all of the assets generated by your build process.
precacheAndRoute(self.__WB_MANIFEST)

// Функция для проверки доступности домена
const checkDomainAvailability = async (url) => {
    try {
        const response = await fetch(url, { method: 'HEAD', mode: 'no-cors' })
        return response.type !== 'error'
    } catch (error) {
        return false
    }
}

// Функция для установки флага недоступности домена
const setDomainUnavailableFlag = async () => {
    await self.registration.sync.register(DOMAIN_UNAVAILABLE_FLAG)
}

// Функция для очистки флага недоступности домена
const clearDomainUnavailableFlag = async () => {
    const tags = await self.registration.sync.getTags()
    if (tags.includes(DOMAIN_UNAVAILABLE_FLAG)) {
        await self.registration.sync.unregister(DOMAIN_UNAVAILABLE_FLAG)
    }
}

// Обработчик для API запросов
const apiHandler = async ({ event }) => {
    const { request } = event

    try {
        // Проверяем доступность основного домена
        const isDomainAvailable = await checkDomainAvailability(MAIN_ORIGIN)

        let response;
        if (!isDomainAvailable) {
            await setDomainUnavailableFlag()
            console.log('Main domain is unavailable. Switching to local API.')

            // Делаем запрос к локальному API
            response = await fetch(LOCAL_API, {
                method: request.method,
                headers: request.headers,
                body: request.body
            })
        } else {
            // Очищаем флаг, если домен снова доступен
            await clearDomainUnavailableFlag()

            // Делаем запрос к основному API
            response = await fetch(request)
        }

        if (response.ok) {
            const data = await response.clone().json()
            // Отправляем сообщение клиентскому коду
            self.clients.matchAll().then(clients => {
                clients.forEach(client => {
                    client.postMessage({
                        type: 'API_RESPONSE',
                        payload: data
                    })
                })
            })

            // Кэшируем успешный ответ
            const cache = await caches.open('api-cache')
            await cache.put(request, response)
            return response
        }
    } catch (error) {
        console.error('Error fetching from API:', error)
    }

    // Если запрос не удался, пробуем получить из кэша
    try {
        const cachedResponse = await caches.match(request)
        if (cachedResponse) {
            return cachedResponse
        }
    } catch (error) {
        console.error('Error reading from cache:', error)
    }

    // Если всё не удалось, возвращаем резервные данные
    return new Response(JSON.stringify({
        url: 'https://www.google.com',
        text: 'Google (резервная ссылка)'
    }), {
        headers: { 'Content-Type': 'application/json' }
    })
}

// Регистрируем маршрут для API запросов
registerRoute(
    ({ url }) => url.pathname.startsWith('/api/'),
    apiHandler
)

// Остальные маршруты остаются без изменений
registerRoute(
    ({ request }) => request.destination === 'style',
    new CacheFirst({
        cacheName: 'css-cache',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 50,
                maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
            }),
        ],
    })
)

registerRoute(
    ({ request }) => request.destination === 'script',
    new StaleWhileRevalidate({
        cacheName: 'js-cache',
    })
)

registerRoute(
    ({ request }) => request.destination === 'image',
    new CacheFirst({
        cacheName: 'images',
        plugins: [
            new ExpirationPlugin({
                maxEntries: 60,
                maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
            }),
        ],
    })
)

registerRoute(
    ({ request }) => request.destination === 'document' || request.destination === '',
    new NetworkFirst({
        cacheName: 'others',
        networkTimeoutSeconds: 10,
    })
)

self.addEventListener('sync', async (event) => {
    if (event.tag === DOMAIN_UNAVAILABLE_FLAG) {
        console.log('Domain is unavailable. Using local API.')
        // Здесь можно добавить логику для уведомления пользователя
    }
})

self.addEventListener('fetch', (event) => {
    console.log('Fetch event for ', event.request.url)
})

self.addEventListener('install', (event) => {
    console.log('Service worker installed')
})

self.addEventListener('activate', (event) => {
    console.log('Service worker activated')
})

self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting()
    }
})

